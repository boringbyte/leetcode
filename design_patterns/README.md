## SOLID Principles of Object-oriented Design

- S - Single Responsibility:
  - A class should have only one responsibility.
- O - Open-closed:
  - A class should be open for extension usually by inheritance, but closed for modification.
- L - Liskov substitution:
  - Subclasses should be stand in for their parents without breaking anything.
- I - Interface segregation:
  - Specific interfaces are better than having one do-all interface.
- D - Dependency inversion:
  - We should program towards abstraction, but not implementations. Implementations can vary but not abstractions.


## Main Classification of Design Patterns
- Creational Patterns:
  - Factory Method
    - Defines interface for creating an object
    - Lets subclasses decide which object
    - Defers instantiation of subclasses
    - Also known as Virtual Constructor
    - If we are using if else for creating classes, then we can replace that with this pattern.
  - Abstract Factory
    - Useful for creating families of related or dependent objects without specifying their concrete classes
    - Close cousin of Factory pattern
    - Factory creates one product
    - Abstract Factory creates families of products
    - Defers creation of objects to concrete subclasses
    - Also known as Kit pattern
    - Remember matrix of classes ((GM, Ford) * (Economy, Sport, Luxury))
  - Builder
    - As a creational pattern it is useful for creating objects.
    - Separates construction of complex objects from its representation.
    - Builder does this by encapsulating the construction of the object, object the principle encapsulate what varies.
    - Allows multistep construction process
    - Implementations can vary over a period of time and builder can accommodate such changes
    - Client only sees the abstraction
    - Useful if there are too many arguments in the \__init__ method
  - Prototype
    - This pattern provide alternative to abstract factory pattern and can also be used in conjunction with it.
    - It uses a given instance as a prototype
    - Creates a clone of the prototype
    - Clone can have different attributes
    - Reduce number of classes since we don't class of every variation.
    - It has one prototype interface with clone method
    - There are concrete prototypes which return a copy of itself.
  - Singleton
    - Don't create more than 1 instance for a class
    - Ensure a class has only one instance
    - Singleton provide a global point of access
    - Class responsible for its one instance
- Structural Patterns:
  - Adapter
    - This pattern is used to make one API look like another one that has different methods and signatures.
    - Similar to power adapters used when traveling from one country to another country.
    - Don't repeat yourself (DRY) principle
    - Converts interface of a class into another that clients expect.
    - There are two types of adapters:
      - Object adapters: Composition
      - Class adapters: Inheritance
    - Favor composition over inheritance
  - Bridge
    - Bridge is used to decouple an abstraction from its implementation so that the two can vary independently.
    - Example is when we decouple subscription from discount, we can implement these two independently and then classes grow linearly instead of growing exponentially.
    - This pattern helps in mitigating class explosion problem when you need to create different combination of classes with slight modifications.
    - This is just composition in simple terms.
    - When you see exponential class growth, we can use this pattern.
    - When you see a lot of duplicate code due to classes sharing similar code.
    - Also called as Handle or Body pattern.
    - Other approaches to achieve same results:
      - Prototype
      - Builder
      - Abstract Factory
  - Composite
    - Part of a tree is mini tree. Also called these trees as part-whole hierarchies.
    - A part resembles the whole tree. Composite pattern handles hierarchies.
    - Uniform code for the whole or the part of the tree.
    - Compose objects into tree structures
    - Represent part-whole hierarchies
    - Clients can handle individual objects and collections of objects using the same code
    - All operations are declared in the abstract complement with default implementation for both leaves and composites.
    - Composite pattern provides:
      - Single interface to tree structure.
      - Uniform access to subtrees and leaf nodes.
      - Simplified client code.
      - No need to do run time type checking.
      - Easy to add new kinds of components that share similar interface without changing client code.
    - When to use?
      - When your data fits a tree-like structure
      - Client code can treat data uniformly.
      - Children can maintain parent references.
      - Possible to share components.
      - Can make your design too general by violating Single Responsibility Principle.
  - Decorator
    - Handles explosion of classes problem similar to prototype pattern.
    - Adds additional responsibilities at runtime instead of compile time.
    - Use decorators when:
      - You want to add new functionality to existing objects.
      - Better than having many subclasses.
      - Better than having many properties.
      - Consider using Factory or Builder pattern.
      - Consider using Prototype pattern
  - Facade
    - Puts a new face on something like an API.
    - It comes handy when you have a complex API or a collection of APIs
    - It comes handy when you have several APIs which slightly do different things.
    - It provides unified interface to a set of interfaces and the set of interfaces don't have to be similar
    - This pattern provides a higher level interface
    - Makes the set of interfaces easier to use.
    - Example has five interfaces:
      - connect, cursor, execute, commit and close
    - Implementing facade will result in just one.
  - Flyweight
    - Can be used when your application has many small objects that consume the whole storage and slows down the entire system.
    - Uses single shared object to hold the data.
    - Centralizes state data for many objects. Reduces required object instances.
    - Single instances are no longer independent. All instances controlled the same.
    - Often used with other patterns like: Composite, State, Strategy
  - Proxy
    - Types of proxy
      - Remote proxy: A remote proxy provides a local representation of an object at a different address.
      - Virtual proxy: Creates expensive objects on demand.
      - Protection proxy: Controls the access to the object.
      - Smart reference proxy: Can perform additional actions when accessed.
- Behavioral Patterns:
  - Strategy
    - Most used pattern, and it is used to control the behavior or operation of an object as it is a behavioral pattern.
    - Family of algorithms, encapsulate each one and make them interchangeable.
    - Takes in common inputs and algorithms vary independently, and it is also known as policy pattern.
    - Other variations of strategy are using functions as strategies since functions are first class objects in python.
    - Strategies as lambdas.
    - Also called as Policy pattern.
  - Command
    - Encapsulate a request as an object.
    - Parameterize objects, and it can have different signatures in contrast to the Strategy pattern where signatures are expected to be same
    - Provides a way for Queues and log operations for DB requests.
    - Also known as Action Pattern or Transaction Pattern.
  - State
    - State pattern is used to describe the states of the objects.
    - A shopping can be in any number of states i.e; Empty, Containing some items, At checkout, Paid for
    - Transitions: Adding and removing items, Checking out, Paying for your purchases.
    - Programs operate in some context like shopping cart.
    - Instead of putting the transactions methods in the context object, we put them in the state classes.
    - Transactions are delegated to the state objects and clients interface with the context.
  - Observer
    - One-to-many relationship between a set of objects.
    - When the state of one changes its dependents are notified.
    - Also known as Dependents pattern or Publish-subscribe pattern.
    - Subject notifies observer if there is a change in the state
    - Observer then can get or set state of the subject.
    - Observes should be properly detached when they aren't required anymore.
  - Visitor
    - It is used as a way to add new flexibility to an object structure when ever we want without modifying the class.
    - It does this by building new abstraction for new functionality and at the same time we can keep the new capabilities separate.
    - This approach can break encapsulation.
    - Accept method is required in the other classes which are not visitor to accept the visitor.
    - Class decorators can replace visitors in python.
  - Chain of Responsibility
    - This pattern is used to process a set of incoming requests in an organized way.
    - This is common in GUI applications.
    - Decouple requests from handlers
    - Let multiple handlers see each request
    - Use of chain of handlers
  - Mediator
    - Use when
      - Objects have many interdependencies.
      - Hard to reuse objects with many reference to others.
      - Customize behavior without subclassing.
    - Benefits
      - Reduces need for subclassing
      - Increases reusability by decoupling
      - Simplifies maintenance
      - Colleagues can vary independently
    - Drawbacks
      - Can become overly complex.
      - Centralizes control
      - May make the entire thing a monolith
  - Memento
    - Used to save the state of an object or take checkpoints to fall back when error occurs.
    - Snapshot of game state at point in time.
    - Restore the game to a previous snapshot.
    - Maintain encapsulation.
    - Also called as Token pattern.
  - Null
    - Provides a default object to clients
    - Avoids null references
    - Client need not test for a valid object
    - Creational patterns can benefit.
  - Template
    - Provides a common template to complete a task using different methods.
    - Defines the skeleton of an algorithm
      - Abstract methods: Which must be implemented by any subclass.
      - Concrete methods: Which are common enough and can be overridden if necessary.
      - Hooks: Hook methods do nothing but may be overridden by subclasses if they need to do something specific.
    - Algorithm step order is preserved.
    - These steps are in Template method.
    - Reduces code duplication (DRY)
  - Iterator
    - Iterating over a collection means returning item one by one.
    - Collection exposes method for iteration
    - Hide implementation.
    - There are many ways to do this.
    - Collection could be a list, set, dictionary, tree or anything.
    - Sequence iterator implements \__get_item__()
    - Callable object implements \__iter__() and \__next__()
    - Collections module also provides Iterable, Iterator and Sequence protocol.
    - Use generator expressions
      - (x for x in iterable)
      - (f(x) for x in iterable)
      - (f(x) for x in iterable if <condition>)
  - Interpreter
    - Domain Specific Languages
      - SQL
      - CSS
      - HTML
      - JSON
      - PHP
    - Benefits:
      - Easy to extend the grammar
      - Easy to implement
      - East to change expression processing
    - Drawbacks
      - Complex grammars need maintenance
    - Interpreter is good for simple languages
    - Use when simplicity is important.
    - Idea for scripting languages
    - Related Patterns:
      - Composite
      - Flyweight
      - Visitor
      - Iterator
  