## SOLID Principles of Object-oriented Design

- S - Single Responsibility:
  - A class should have only one responsibility.
- O - Open-closed:
  - A class should be open for extension usually by inheritance, but closed for modification.
- L - Liskov substitution:
  - Subclasses should be stand in for their parents without breaking anything.
- I - Interface segregation:
  - A specific interfaces are better than having one do-all interface.
- D - Dependency inversion:
  - We should program towards abstraction, but not implementations. Implementations can vary but not abstractions.


## Main Classification of Design Patterns
- Creational Patterns:
  - Factory Method
    - Defines interface for creating an object
    - Lets subclasses decide which object
    - Defers instantiation of subclasses
    - Also known as Virtual Constructor
    - If we are using if else for creating classes, then we can replace that with this pattern.
  - Abstract Factory
    - Useful for creating families of related or dependent objects without specifying their concrete classes
    - Close cousin of Factory pattern
    - Factory creates one product
    - Abstract Factory creates families of products
    - Defers creation of objects to concrete subclasses
    - Also known as Kit pattern
    - Remember matrix of classes ((GM, Ford) * (Economy, Sport, Luxury))
  - Builder
    - As a creational pattern it is useful for creating objects.
    - Separates construction of complex objects from its representation.
    - Builder does this by encapsulating the construction of the object, object the principle encapsulate what varies.
    - Allows multistep construction process
    - Implementations can vary over a period of time and builder can accommodate such changes
    - Client only sees the abstraction
    - Useful if there are too many arguments in the __init__ method
  - Prototype
    - This pattern provide alternative to abstract factory pattern and can also be used in conjunction with it.
    - It uses a given instance as a prototype
    - Creates a clone of the prototype
    - Clone can have different attributes
    - Reduce number of classes since we don't class of every variation.
    - It has one prototype interface with clone method
    - There are concrete prototypes which return a copy of itself.
  - Singleton
    - Don't create more than 1 instance for a class
    - Ensure a class has only one instance
    - Singleton provide a global point of access
    - Class responsible for its one instance
- Structural Patterns:
  - Adapter
    - This pattern is used to make one API look like another one that has different methods and signatures.
    - Similar to power adapters used when traveling from one country to another country.
    - Don't repeat yourself (DRY) principle
    - Converts interface of a class into another that clients expect.
    - There are two types of adapters:
      - Object adapters: Composition
      - Class adapters: Inheritance
    - Favor composition over inheritance
  - Bridge
    - -
  - Composite
    - Part of a tree is mini tree. Also called as part-whole hierarchies.
    - A part resembles the whole tree. Composite pattern handles hierarchies.
    - Uniform code for the whole or the part of the tree.
    - Compose objects into tree structures
    - Represent part-whole hierarchies
    - Clients can handle individual objects and collections of objects using the same code
  - Decorator
    - Handles explosion of classes problem similar to prototype pattern.
    - Adds additional responsibilities at runtime instead of compile time.
    - Use decorators when:
      - You want to add new functionality to existing objects.
      - Better than having many subclasses.
      - Better than having many properties.
      - Consider using Factory or Builder pattern.
      - Consider using Prototype pattern
  - Facade
    - Puts a new face on something like an API.
    - It comes handy when you have a complex API or a collection of APIs
    - It comes handy when you have several APIs which slightly do different things.
    - It provided unified interface to a set of interfaces and the set of interfaces don't have to be similar
    - This pattern provides a higher level interface
    - Makes the set of interfaces easier to use.
    - Example has five interfaces:
      - connect, cursor, execute, commit and close
    - Implementing facade will result in just one.
  - Flyweight
    - Can be used when your application has many small objects that consume the whole storage and slows down the entire system.
    - Uses single shared object to hold the data.
    - Centralizes state data for many objects. Reduces required object instances.
    - Single instances are no longer independent. All instances controlled the same.
    - Often used with other patterns like: Composite, State, Strategy
  - Proxy
    - Types of proxy
      - Remote proxy: A remote proxy provides a local representation of an object at a different address.
      - Virtual proxy: Creates expensive objects on demand.
      - Protection proxy: Controls the access to the object.
      - Smart reference proxy: Can perform additional actions when accessed.
- Behavioral Patterns:
  - Strategy
    - Most used pattern, and it is used to control the behavior or operation of an object as it is a behavioral pattern.
    - Family of algorithms, encapsulate each one and make them interchangeable.
    - Takes in common inputs and algorithms vary independently, and it is also known as policy pattern.
    - Other variations of strategy are using functions as strategies since functions are first class objects in python.
    - Strategies as lambdas.
  - Command
    - Encapsulate a request as an object.
    - Parameterize objects and it can have different signatures.
    - Provides a way for Queues and log operations for DB requests.
  - State
    - A state pattern is used to describe the states of the objects.
    - A shopping can be in any number of states i.e; Empty, Containing some items, At checkout, Paid for
    - Transitions: Adding and removing items, Checking out, Paying for your purchases.
    - Programs operate in some context like shopping cart.
    - Instead of putting the transactions methods in the context object, we put them in the state classes.
    - Transactions are delegated to the state objects and clients interface with the context.
  - Observer
  - Visitor
  - Chain of Responsibility
  - Mediator
  - Memento
  - Null
  - Template
  - Iterator
  - Interpreter